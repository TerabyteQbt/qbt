import com.google.common.collect.ImmutableList;
import java.nio.file.Paths;
import qbt.artifactcacher.CompoundArtifactCacher;
import qbt.artifactcacher.LocalArtifactCacher;
import qbt.config.CompoundQbtRemoteFinder;
import qbt.config.FormatLocalRepoFinder;
import qbt.config.FormatQbtRemoteFinder;
import qbt.config.MapQbtRemoteFinder;
import qbt.config.QbtConfig;
import qbt.pins.SimpleLocalPinsRepo;
import qbt.remote.FormatQbtRemote;
import qbt.remote.GithubQbtRemote;
import qbt.vcs.VcsRegistry;

def dotQbt = Paths.get(System.getenv("HOME")).resolve(".qbt");
def gitRemoteVcs = VcsRegistry.getRawRemoteVcs("git");
def gitLocalVcs = gitRemoteVcs.getLocalVcs();

// uncomment this and edit the file to include a github token if desired.
//def github_api_token = new File(System.getenv("HOME") + '/.github-api-token').text.trim();
def github_api_token = null

return new QbtConfig(

// First config argument -- where are my overrides?  My simple choice is
// "next to meta".  LocalRepoFinder is an interface and it's entirely
// plausible to implement it in other ways, possibly even in qbt-config
// itself.  You could also replace this with an absolute path like:
// System.getenv("HOME") + "/projects/%r")
     new FormatLocalRepoFinder(
         gitLocalVcs,
         workspaceRoot.resolve("../%r").toString(),
     ),

// Second config argument -- where are my local pins?  local pins are commits in
// package repositories that are pointed to by the manifest.  If you push the
// repository that the manifest file lives in to other people, they can't use it
// unless they can also get all the commits listed in that manifest, so pins are
// how QBT accomplishes this.
// 
// I put them in my home directory so they're shared between workspaces.  Since
// this is an immutable, append-only store sharing mostly makes sense.  I notice
// this is slightly inconsistent specification-wise: most of the rest are
// formats and this one is root directory that it makes subdirs of.  Should
// probably go back and change this to format.
     new SimpleLocalPinsRepo(
         gitRemoteVcs,
         dotQbt.resolve("pins/v1"),
     ),

// Third config argument -- where are my remotes?  This is just a
// programmatic mapping from mere string to full-on QbtRemote platform
// object.
// 
// The first half specifies two fixed ones by name.  "terabyte" is one QBT
// universe on GitHub and "amling" is another.  You could create your own
// (probably called "origin") by following the docs under "forking a universe".
// This means anywhere that takes a remote can be given "cmyers" or "amling"
// or whatever and it will pick these guys.
// 
// The second half will always "hit" and treats the string as a format
// string.  This means I could pass those above format string in place of
// their short names and get the same effect, just like how you can "git fetch"
// a git url or a remote name.
     new CompoundQbtRemoteFinder([
         new MapQbtRemoteFinder([

             // Here is an example "github aware" remote
             // This will automatically create package repos if they don't exist
             //
             // IF YOU USE GITHUB, YOU PROBABLY JUST WANT TO COPY THIS AND
             // MODIFY IT TO POINT AT YOUR GITHUB ORGANIZATION AND CALL IT "origin".
             amling: new GithubQbtRemote(
                gitRemoteVcs,
                github_api_token, // make sure you fill in your github api token above
                "AmlingQbt", // username or organization name, can contain %r and/or %h
                // optional 4th argument is the remote repository name, defaults to "%r"
             ),
             // The FormatQbtRemote works with any format string git
             // understands as a remote, but makes no assumptions about it
             // being github (so it won't, for example, try to call the rest
             // API to create repositories.
             terabyte: new FormatQbtRemote(
                 gitRemoteVcs,
                 "https://github.com/TerabyteQbt/%r.git",
             ),
             // GithubQbtRemote and FormatQBtRemote both implement the
             // QbtRemote interface.  You can add your own implementations to
             // handle different servers, autovivification of repositories,
             // auth, etc.
             // custom: new ClassThatImplementsQbtRemote(
             //     gitRemoteVcs, // <-- you probably need one of these in your ctor
             //     "ssh://git@github.com/TerabyteQbt/%r.git", <-- whatever other args you need
             // ),
         ]),
         // Having this at the bottom of the chain lets you pass git remotes in
         // directly, i.e. `qbt pushPins git@github.com/TerabyteQbt/%r.git`
         new FormatQbtRemoteFinder(
             gitRemoteVcs,
         ),
     ]),

// Finally, artifact caching locations and the size of the local cache.  You can
// probably use this unmodified.  Cache size below is 5G and stored in your
// dotQbt directory.
     new CompoundArtifactCacher(
         ImmutableList.of(
             new LocalArtifactCacher(
                 dotQbt.resolve("artifacts/v1"),
                 5L * (1024 * 1024 * 1024)
             ),
         ),
     ),
);
